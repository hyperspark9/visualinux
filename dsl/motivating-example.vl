import lib.containers
import lib.concurrency

define VMFile_t as Box<file> [
    Text<string> filename: f_path.dentry.d_name.name
]

define AnonVMA_t as Box<anon_vma> [
    Link parent -> @parent
] where {
    parent = AnonVMA_t(@this.parent)
}

define VMArea_t as Box<vm_area_struct> [
    Text<u64:x> vm_start, vm_end
    Text<flag:vm_basic> vm_flags
    Link vm_file -> @vm_file
    Link anon_vma -> @anon_vma
] where {
    vm_file = VMFile_t(@this.vm_file)
    anon_vma = AnonVMA_t(@this.anon_vma)
}

define MapleTreeNode_t as Box [
    Text<enum:maple_type> type: @type
    Text<u64:x> min: @ma_min
    Text<u64:x> max: @ma_max
    Shape slots: @slots
    Shape pivots: @pivots
] where {
    is_leaf = ${mte_is_leaf(@this)}
    node = ${mte_to_node(@this)}
    type = ${mte_node_type(@this)}
    last_ma_min = @ma_min
    last_ma_max = @ma_max
    slots = switch @type {
    case ${maple_dense}:
        Array(@node.slot).forEach |item| {
            ma_min = ${@last_ma_min + @index}
            ma_max = @ma_min
            yield Box [ Link slot -> @slot ] where {
                slot = VMArea_t(@item)
            }
        }
    case ${maple_leaf_64}, ${maple_range_64}:
        Array(@node.mr64.slot).forEach |item| {
            pivots = ${@node.mr64.pivot}
            yield Box [ Link slot -> @slot_safe ] where {
                slot_entry = @item
                slot_length = ${sizeof(@pivots) / sizeof(void *)}
                ma_min = ${@index > 0 ? @pivots[@index - 1] + 1 : @last_ma_min}
                ma_max = ${@index < @slot_length - 1 ? @pivots[@index] : @last_ma_max}
                slot_safety_check_1 = ${@index > 0 && @pivots[@index - 1] == @last_ma_max}
                slot_safety_check_2 = ${@index > 0 && @pivots[@index - 1] == 0}
                slot_safety_check_3 = ${@index > 0 && @index < @slot_length - 1 && @pivots[@index] == 0}
                slot_safety_check   = ${@slot_safety_check_1 || @slot_safety_check_2 || @slot_safety_check_3}
                slot_safe = switch ${@slot_safety_check * 10 + @is_leaf} {
                case ${0}: MapleTreeNode_t(maple_node: @slot_entry)
                case ${1}: VMArea_t(@slot_entry)
                otherwise: NULL
                }
            }
        }
    case ${maple_arange_64}:
        Array(@node.ma64.slot).forEach |item| {
            pivots = ${@node.ma64.pivot}
            yield Box [ Link slot -> @slot_safe ] where {
                slot_entry = @item
                slot_length = ${sizeof(@pivots) / sizeof(void *)}
                ma_min = ${@index > 0 ? @pivots[@index - 1] + 1 : @last_ma_min}
                ma_max = ${@index < @slot_length - 1 ? @pivots[@index] : @last_ma_max}
                slot_safety_check_1 = ${@index > 0 && @pivots[@index - 1] == @last_ma_max}
                slot_safety_check_2 = ${@index > 0 && @pivots[@index - 1] == 0}
                slot_safety_check_3 = ${@index > 0 && @index < @slot_length - 1 && @pivots[@index] == 0}
                slot_safety_check   = ${@slot_safety_check_1 || @slot_safety_check_2 || @slot_safety_check_3}
                slot_safe = switch ${@slot_safety_check * 10 + @is_leaf} {
                case ${0}: MapleTreeNode_t(maple_node: @slot_entry)
                case ${1}: VMArea_t(@slot_entry)
                otherwise: NULL
                }
            }
        }
    otherwise:
        Box [ Text unkown_type: @type ]
    }
    pivots = switch @type {
    case ${maple_dense}: NULL
    case ${maple_leaf_64}, ${maple_range_64}:
        Array(@node.mr64.pivot).forEach |item| {
            yield Box [ Text<u64:x> pivot: @item ]
        }
    case ${maple_arange_64}:
        Array(@node.ma64.pivot).forEach |item| {
            yield Box [ Text<u64:x> pivot: @item ]
        }
    }
}

define MapleTree_t as Box<maple_tree> [
    Text<emoji:lock> ma_lock: ma_lock.rlock.raw_lock.locked
    Link ma_root -> @ma_root
    Text<flag:maple_tree> ma_flags
    Text height: ${mt_height(@this)}
    Text<bool> in_rcu: ${mt_in_rcu(@this)}
    Text<bool> ext_lk: ${mt_external_lock(@this)}
] with [
    MapleTreeNode_t: false
] where {
    ma_root_entry = @this.ma_root
    type = ${(int)mte_node_type(@ma_root_entry)}
    ma_min = ${0}
    ma_max = ${mt_max[@type]}
    ma_root = switch ${!xa_is_node(@ma_root_entry)} {
    case ${true}:
        Box [ Text ma_root: @ma_root_entry ]
    case ${false}:
        MapleTreeNode_t(maple_root: @this.ma_root)
    }
}

define MMStruct_t as Box<mm_struct> {
    :default [
        Text<u64:x> mmap_base
        Text mm_count: mm_count.counter
        Text map_count
        Link mm_mt -> @mm_mt
    ]
    :default => :show_locks [
        // Spinlock page_table_lock
        // RWSemaphore mmap_lock
    ]
} where {
    mm_mt = MapleTree_t(@this.mm_mt)
}

define Task_t as Box<task_struct> [
    Text pid, comm
    Text<string> state: ${get_task_state(@this)}
    Link mm -> @mm
    Link active_mm -> @active_mm
] where {
    mm = MMStruct_t(@this.mm)
    active_mm = MMStruct_t(@this.active_mm)
}

// rcu

define RCUCallbackHead as Box<callback_head> [
    Link next -> @next
    Text<fptr> func
] where {
    next = switch @this.next.func {
    case ${&mt_free_rcu}:
        Box<maple_node.rcu>(@this.next) [
            RCUCallbackHead rcu
        ]
    otherwise:
        RCUCallbackHead(@this.next)
    }
}

define RCUSegCBList as Box<rcu_segcblist> [
    Link head -> @head
    Text<flag> flags
    Text len
    TextArray seglen
] where {
    head = switch @this.head.func {
    case ${&mt_free_rcu}:
        Box<maple_node.rcu>(@this.head) [
            RCUCallbackHead rcu
        ]
    otherwise:
        RCUCallbackHead(@this.head)
    }
}

define RCUData as Box<rcu_data> [
    Text cpu
    RCUSegCBList cblist
]

// view

current_task = Task_t(${per_cpu(current_task, 0)})
cpu_rcu_data = RCUData(${&per_cpu(rcu_data, 0)})
// focus @cpu_rcu_data on RCUCallbackHead where @this.func == &mt_free_rcu

view mm_current {
    plot @current_task
    plot @cpu_rcu_data
}
