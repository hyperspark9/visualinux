define XAEntry as Box [
    Text this: @this
]

define XANode as Box [
    Text xa_shift:  @last_xa_shift
    Text xa_index:  @last_xa_index
    Text shift:     @node.shift
    Text offset:    @node.offset
    Text count:     @node.count
    Text nr_values: @node.nr_values
    Shape slots: @slots
] where {
    last_xa_index = @xa_index
    last_xa_shift = @xa_shift
    node = ${xa_to_node(@this)}
    slots = Array(@node.slots).forEach |item| {
        xa_entry = @item
        xa_shift = @node.shift
        slot = switch ${1} {
            case ${xa_is_node(@xa_entry) && @xa_shift != 0}:
                Box [ Link slot -> @slot ] where {
                    xa_index = ${@last_xa_index + (@index << @xa_shift)}
                    slot = XANode(@xa_entry)
                }
            case ${xa_is_node(@xa_entry) && @xa_shift == 0}: Box(@xa_entry) [ Text entry_node:     @this ]
            case ${xa_is_value(@xa_entry)}:                  Box(@xa_entry) [ Text entry_value:    ${xa_to_value(@this)} ]
            case ${!xa_is_internal(@xa_entry)}:
                Box [ Link entry -> @entry ] where {
                    entry = XAEntry(@xa_entry)
                }
            case ${xa_is_retry(@xa_entry)}:                  Box(@xa_entry) [ Text entry_internal: ${xa_to_internal(@this)} ]
            case ${xa_is_sibling(@xa_entry)}:                Box(@xa_entry) [ Text entry_sibling:  ${xa_to_sibling(@this)} ]
            case ${xa_is_zero(@xa_entry)}:                   Box(@xa_entry) [ Text entry_zero:     ${xa_to_internal(@this)} ]
            otherwise:                                       Box(@xa_entry) [ Text entry_unknown:  @this ]
        }
        yield @slot
    }
}

define XArray as Box<xarray> [
    Text xa_flags
    Link xa_head -> @xa_head
] where {
    xa_entry = @this.xa_head
    xa_index = ${0}
    xa_shift = ${xa_is_node(@xa_entry) ? xa_to_node(@xa_entry)->shift + XA_CHUNK_SHIFT : 0}
    xa_head = switch ${1} {
        case ${xa_is_node(@xa_entry) && @xa_shift != 0}: XANode(@xa_entry)
        case ${xa_is_node(@xa_entry) && @xa_shift == 0}: Box [ Text entry:          @xa_entry ]
        case ${xa_is_value(@xa_entry)}:                  Box [ Text entry_value:    ${xa_to_value(@xa_entry)} ]
        case ${!xa_is_internal(@xa_entry)}:              Box [ Text entry:          @xa_entry ]
        case ${xa_is_retry(@xa_entry)}:                  Box [ Text entry_internal: ${xa_to_internal(@xa_entry)} ]
        case ${xa_is_sibling(@xa_entry)}:                Box [ Text entry_sibling:  ${xa_to_sibling(@xa_entry)} ]
        case ${xa_is_zero(@xa_entry)}:                   Box [ Text entry_zero:     ${xa_to_internal(@xa_entry)} ]
        otherwise:                                       Box [ Text entry_unknown:  @xa_entry ]
    }
}

define IDR as Box<idr> [
    XArray idr_rt
    Text idr_base
    Text idr_next
]

define PidNamespace as Box<pid_namespace> [
    IDR idr
    Text pid_allocated
    Text level
    Link parent -> @parent
] where {
    parent = PidNamespace(@this.parent)
}

pid_ns = PidNamespace(${task_active_pid_ns(per_cpu(current_task, 0))})
view pid_namespace {
    plot @pid_ns
}
